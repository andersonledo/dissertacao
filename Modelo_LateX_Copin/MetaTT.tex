\chapter{MetaTT}

\label{section_metacg}

Este trabalho propõe MetaTT, um abordagem com base em metamodelos para a escrita de geradores de código M2T. Ela guia a organização, especificação e fluxo de controle entre as transformações M2T a partir das informações providas pelo metamodelo. MetaTT consiste em:


%We propose MetaTT, a Metamodel based approach for writing M2T generators. It guides the organization, specification and control flow among model-to-text transformations from the information provided by a metamodel. MetaTT consists of:

\begin{enumerate}
 \item 
Uma arqutetura que deve ser seguida pelas transformações M2T geradas. Esta arquitetura é formada por módulos, sub-módulos e contratos entre esses artefatos que, juntos, objetivam alcancçar um auto nível de reúso de automação;
%An architecture that must be followed by the generated M2T transformations. Such architecture comprises the modules, sub-modules and contract that together aim at achieving a higher level of automation and reuse. 
\item
Uma abordagem operacional que indica como os artefatos propostos na arquitetura devem ser implementados, \textit{i.e.}, que indica quais são as transformações e regras devem aparecer em cada módulo precrito em (1).

%The stepwise approach that states how to fulfill the artifacts in the proposed architecture, (\textit{i.e.}, that indicates which transformations and rules must appear in each module prescribed in (1)).
\end{enumerate}

Na Fig.~\ref{metattprocess} ilustra-se como um desenvolvedor pode usar o MetaTT e como as transformações resultantes pode ser udadas para a geração da sintaxe concreta a partir dos modelos. Na regição 1, ilustra-se como os desenvolvedores precisam interagir com o suporte ferramental de MetaTT (explicado no Cap.~\ref{toolsuport}) a fim de produzir transformações M2T:

%In Fig.~\ref{metattprocess} we illustrate how the developer can use MetaTT and how the resulting transformations can be used for the generation of concrete syntax from models. In region 1, we illustrate how the developer needs to interact with the MetaTT tool support (later detailed) in order to produce the M2T transformations:
\begin{enumerate}
 \item O desenvolvedor provê um metamode para a ferramenta MetaTT; 
  %The developer provides a metamodel to the MetaTT tool.

 \item MetaTT usa este metamodelo para gerar o conjunto de transformações que seguem a arquitetura padronizada conforme prescrito na Sec.~\ref{metatt-architecture}; 
  %MetaTT uses such metamodel for generating a set of M2T transformations that follow a standardized architecture prescribed by MetaTT.

 \item O desenvolvedor complementa a implementação das regras que foram geradas como \textit{stubs} pelo MetaTT no móudulo \textit{Templates};  %The developer, then, writes the rules fulfilling the rule stubs previously generated by MetaTT in the \textit{Templates} module.

 \item O desenvolvedor precisa inspecionar as transformações do módulo \textit{Main} e ajustá-las a fim de que reflitam as decisões de design do próprio desenvolvedor no gerador M2T, tais como escolhas de elemento raiz a ser transformado.
  %The developer needs to inspect the transformations from the \textit{Main} module and adjust them to reflect his or her design decisions in the M2T generator, such as the choice of the root element to be transformed.
\end{enumerate}


\begin{figure}[htb!]
	\begin{center}
	 \includegraphics[scale=.5]{metattprocess}
	\caption{MetaTT usage overview.}
	\label{metattprocess}
	\end{center}
\end{figure}

Na região 2 (\textit{region 2}) da Fig.~\ref{metattprocess}, ilustra-se como as transformações M2T geradas são usadas para mapear modelos em sintaxe concreta.
%In region 2 of Fig.~\ref{metattprocess}, we illustrate how the generated M2T transformations are used to map models into concrete syntax.
Este processo funciona da seguinte maneira: uma instância do metamodelo provido é dada como entrada para o gerador de sintaxe concreta, que foi obtido a apartir do MetaTT. O gerador executa as transformações sobre o modelo de entrada e, como resultado de sua execução, tem-se os arquivos gerados, tais como arquivos de documentação, código fonte Java, arquivos XML, etc.
%This process works as follows. A model instance of the provided metamodel is given as input for the concrete syntax generator (the tool capable of performing the M2T transformations), generated by MetaTT, over the input model. As output of the concrete syntax generator, we have the generated files, such as documentation files, Java source code, XML files, etc.

Nosso trabalho é capaz de descrever como construir a infraestrutura de um gerador M2T, independentemente do metamodelo para o qual a sintaxe concreta precisa ser gerada. Os detalhes sobre a arquitetura e a geração dos artefatos arquiteturais são discutidos nas próximas seções.

%Our approach is capable of describing how to build the M2T generator infrastructure, independently of the metamodel from which the concrete syntax must be generated. The details about the architecture and the generation of the architectural artifacts are discussed in the next subsections.

\section{Arquitetura}
\label{section_package_structure}

O MetaTT organiza a gerador M2T em três módulos principais: \textit{Main}, \textit{Core} e \textit{Templates}, mostrados na Fig.~\ref{packages}. O módulo \textit{Main} é responsável pelo começo do processo de transformação e por obter a sintaxe concreta resultante dos processos realizados no módulo \textit{Core} bem como persistir este resultado. O módulo \textit{Core} extrai informação dos modelos dados como entrada e usa a sintaxe definida no módulo \textit{Templates}. O módulo \textit{Templates} é responsável por manter as definições de sintaxe.
%MetaTT organizes the M2T generator into three main modules: \textit{Main}, \textit{Core} and \textit{Templates}, shown in Fig.~\ref{packages}. The \textit{Main} module is responsible for starting the transformation and getting the resulting concrete syntax from \textit{Core} module as well as persisting it. The \textit{Core} module extracts information from the input models and uses the syntax definition from \textit{Templates} module that in turn is responsible for defining the concrete syntax. 


Como mostrado na Fig.~\ref{packages}, os módulos \textit{Core} e \textit{Templates} são compostos de outros submódulos responsáveis por tarefas específicas. O módulo \textit{Templates} não depende de nenhum outro módulo, já o módulo \textit{Main} atua como cliente do módulo \textit{Core}, que concentra o processo de geração de código. Cada módulo, e submódulos correspondentes, são explicados nas próximas seções.
%As can be noted in Fig.~\ref{packages}, the \textit{Core} and \textit{Templates} modules are further composed of others submodules addressing specific tasks. The \textit{Templates} module does not depend on any other module, whereas the \textit{Main} module plays the client role of the \textit{Core} module, which concentrates the text generation process. Each module and corresponding submodules are explained in the next subsections.


\begin{figure}
\begin{center}
 	\includegraphics[scale=.5]{Architecture_vertical}
	\caption{A arquitetura prescrita por nosso trabalho para geradores de código M2T.}
	\label{packages}
\end{center}
\end{figure}


\subsection{Módulo \textit{Templates}}
\label{subsection_templates}

Este módulo provê a definição de sintaxe concreta para a linguagem alvo. Por exemplo, considerando a linguagem de programação Java como a linguagem alvo, este módulo conterá a especificação da sintaxe concreta para as assinaturas de métodos, declarações de tipos, as palavras chaves, etc.

%This module provides the concrete syntax definition for a target language. For instance, considering Java programming language as the target language, this module will contain the specification of the concrete syntax to the method signatures, the type declarations, the keywords, etc.

Este módulo é formado por um conjutno de regras de templates (\textit{template rules}) e tabelas de símbolos (\textit{symbol tables}). As regras de templates provêem a definição da sintaxe para elementos não-terminais que aparecem no metamodelo e para os quais precisa-se gerar sintaxe concreta. As tabelas de símbolos provêem partes individuais de sintaxe para elementos terminais que não estão metamodelados, \textit{e.g.}, palavras chaves, caracteres separadores, delimitadores de bloco, etc.

%This module comprises a set of \textit{template rules} and \textit{symbol tables}. The former provides the syntax definition for the non-terminal elements appearing in the metamodel to which the concrete syntax must be generated. The latter provides individual pieces of syntax for terminal elements that are not metamodeled as metaelements, \textit{e.g.}, keywords, separator characters, block delimiters, etc.

Sempre que necessita-se de alguma informação referente à sintaxe concreta no processo de geração de texto, esta informação é obtida do módulo \textit{Templates} através das interfaces \textit{ITextDefinitions} e \textit{ITextDelimiters}, que dão acesso aos submódulos \textit{TextualDefinitions} e \textit{TerminalSymbols}, respectivamente. O submódulo \textit{TextualDefinitions} contém as regras de template (\textit{template rules}), e cada uma delas define a um template específico para cada metaclasse do metamodelo. O submódulo \textit{TerminalSymbols} contém as tabelas de símbolos (\textit{simbol tables}) que contém as contantes \textit{strings} correspondente aos terminais da linguagem (\textit{e.g.}, chaves, separadores, ponto e vírgula, palavas chaves, etc.). Sempre que algum símbolo terminal é requerido em uma regra do submódulo \textit{TextualDefinitions}, esta informação é acessada no submódulo \textit{TerminalSymbols} através da interface \textit{ITerminals}.

%Whenever concrete syntax information is required in the process of text generation, this information is obtained from the \textit{Templates} module by means of the \textit{ITextualDefinitions} and \textit{ITextualDelimiters} interfaces that give access to the \textit{TextualDefinitions} and to the \textit{TerminalSymbols} sub-modules, respectively. The \textit{Textual Definitions} sub-module contains the \textit{template rules}, where each one of them defines a particular template for each metaclass of the metamodel. The \textit{TerminalSymbols} sub-module contains the \textit{symbol tables} that contain the string constants corresponding to language terminals (\textit{e.g.}, braces, separators, semicolon, keywords, etc.). Whenever the rules in the \textit{TextualDefinitions} sub-module needs terminal symbols, it access the \textit{TerminalSymbols} sub-module through the \textit{ITerminals} interface.

\begin{figure}[htb]
\begin{mofscript}	
	\begin{lstlisting}[frame=single]
property LEFT_PARENTHESES:String= ``(''
property RIGHT_PARENTHESES:String= ``)''
property LEFT_CURLY_BRACES:String= ``{''
property RIGHT_CURLY_BRACES:String= ``}''
...
property IF:String=``if''
property ELSE:String=``else''
...
property DECLARATION_BEGIN_BLOCK_DELIMITER:String=LEFT_CURLY_BRACES
property DECLARATION_SEPARATOR:String=``\n\t''
property DECLARATION_END_BLOCK_DELIMITER:String=RIGHT_CURLY_BRACES
	\end{lstlisting}
\end{mofscript}
\caption{Delimitadores de bloco para uma declaração em PLang. Um exemplo de uma tabela de símbolos.}
\label{mofscript_delimiters}
\end{figure}

Na Fig.~\ref{mofscript_delimiters} ilustra-se parte da tabela de símbolos provida para o caso do PLang, na qual cada símbolo é definido como uma constante \textit{string} (definido como uma propriedade de MOFScript) que referencia caracteres que podem ser usados na definição da sintaxe. Nas linhas 1-4, caracteres de uso frequente são ilustrados (chaves esquerda e direita, parênteses esquerdo e direito). Tais caracteres podem ser reusados em várias regras de templates e outras definições (\textit{e.g.}, nas linhas 9 e 11 e, mais à frente, na Fig.~\ref{templaterule}). Nas linhas 6 e 7, são mostradas palavras chaves específicas de uma expressão condicional (\textit{ConditionalExp}). Nas linhas 9-11, são mostrados alguns caracteres usados em declarações de blocos, tais como chaves esquerda (linha 9), caracter de fim de linha seguido por um caracter de \textit{tab} (linha 10) ou chave direita (linha 11).

%In Fig.~\ref{mofscript_delimiters} we illustrate part of the symbol table provided to PLang, in which each symbol is defined as a string constant (defined as a MOFScript property) that holds characters to be used in the syntax definition. At lines 1-4, commonly used characters are illustrated (left and right curly braces, left and right parentheses). Such characters can be reused in many template rules and other definitions (\textit{e.g.}, at lines 9 and 11 and, later, in Fig.~\ref{templaterule}). At lines 6 and 7, specific keywords of the PLang \textit{ConditionalSttmnt} element are shown. At lines 9-11, some characters used in block of declarations, such as left curly brace (line 9), end line character followed by a tab character (line 10) or right curly brace (line 11), are shown.

Quando um desenvolvedor de transformações M2T precisa especificar a definição da sintaxe para um dado elemento no MetaTT, ele ou ela precisa definir os valores do elementos terminais na tabela de símbolos e definir como as regras de templates devem combinar esses elementos de maneira que formem a sintaxe para os elementos não-terminais. Por exemplo, supondo que o desenvolvedor decidiu que um comando condicional (\textit{ConditionalSttmnt} deve ter a sintaxe de acordo com o trecho da gramática BNF mostrado na Fig.~\ref{grammar}, então ele ou ela define a sintaxe concreta na regra de template como mostrado na Fig.~\ref{templaterule}.


%When a M2T transformation developer needs to specify the syntax definition for a given element in MetaTT, he or she needs to define the values of the terminal elements in the \textit{symbol tables} and to define how the \textit{template rules} should arrange these elements in order to form the syntax for the non-terminal ones. For instance, suppose the developer has decided that a PLang \textit{ConditionalSttmnt} should have a syntax definition according the the excerpt of a BNF grammar shown in Fig.~\ref{grammar}, then he or she defines its concrete syntax as a \textit{template rule} as shown in Fig.~\ref{templaterule}.

\begin{figure}[htb]
\begin{center}
\begin{tabular}{|rl|}
\hline
sttmnt $\rightarrow$ &  \textbf{if} exp \textbf{then} sttmnt\\
 |& \textbf{if} exp \textbf{then} sttmnt \textbf{else} sttmnt\\
\hline
\end{tabular}
\end{center}
\caption{An excerpt of a BNF grammar for the PLang ConditionalSttmnt with non-terminal elements in normal font and terminal elements in bold font.}
\label{grammar}
\end{figure}


\begin{figure}[htb!]
\begin{mofscript}
	\begin{lstlisting}[frame=single]
module::conditionalSttmntTemplate(condition:String,thenSttmnts:String,elseSttmnts:String):String{
 var code: String = ``''
            
 code += IF+LEFT_PARENTHESES+condition+RIGHT_PARENTHESES
 code += LEFT_CURLY_BRACES+``\n''
 code += thenSttmnts+``\n''
 code += RIGHT_CURLY_BRACES

 if(not elseSttmnts.trim() = ``''){
  code += ELSE+LEFT_CURLY_BRACES+``\n''
  code += elseSttmnts+``\n''
  code += RIGHT_CURLY_BRACES
 }
 result = code
}
\end{lstlisting}
\end{mofscript}
\caption{Implementation of a template rule for the BNF grammar described in Fig.~\ref{grammar}.}
\label{templaterule}
\end{figure}

A Fig.~\ref{templaterule} ilustra a regra \textit{conditionalSttmntTemplate}, que recebe a sintaxe concreta, extraída previamente, dos elementos realacionados: \textit{(i)} uma condição (\textit{condition}), \textit{(ii)} um bloco de comandos para a condição avaliada como verdadeira (\textit{thenSttmnts}), seguido \textit{(iii)} de um bloco de comandos para a condição avaliada como falsa (\textit{elseSttmnts}). Nas linhas 9-13, the bloco de comandos \textit{else} é acrescentado à saída do programa apenas se o argumento \textit{else} não for vazio.

%Fig.~\ref{templaterule} illustrates the \textit{conditionalSttmntTemplate} rule, that receives the previously extracted concrete syntax of three related elements: \textit{(i)} a condition, \textit{(ii)} the then  block statement and \textit{(iii)} the else block statement. At lines 4-7 these elements are combined with terminal strings (defined in the \textit{TerminalSymbols module}) in order to form the concrete syntax for the \textit{condition} followed by the \textit{then} statement. At lines 9-13, the \textit{else} statement is appended if it is not an empty string.

Um exempo de saída textual para a regra de template na Fig.~\ref{templaterule} é o código na Fig.~\ref{templateruleoutput}.

%An example of the text output of the \textit{template rule} in Fig.~\ref{templaterule} is the code in Fig.~\ref{templateruleoutput}.


\begin{figure}[htb!]
\begin{mofscript}
	\begin{lstlisting}[frame=single]
if(a < b){
 println(``a is smaller than b'')
}else{
 println(``a is greater than or equal to b'')
}
\end{lstlisting}
\end{mofscript}
\caption{Example of a code outputted from the \textit{template rule} in Fig.~\ref{templaterule}.}
\label{templateruleoutput}
\end{figure}



Uma das principais características da abordagem do MetaTT é simplificar a definição da sintaxe concreta e desacoplar o módulo \textit{Templates} dos outros módulos do gerador M2T. Dessa maneira, quando alguma mudança na especificação da sintaxe concreta precisa ser feita, ela é realizada com a modificação de um regra e uma tabela de símbolos bem dedfinidas e localizadas. Como resultado, pode-se alterar a sintaxe concreta a ser gerada trocando-se os artefatos do módulo \textit{Templates} por outros (respeitando-se os contratos das interfaces????), sem precisar mudar outros módulos.

%One of the main features of the MetaTT approach is simplifying the concrete syntax definition and decoupling the \textit{Templates} module from the remaining  modules of the M2T generator. Therefore, when some change in the concrete syntax specification needs to be done, it is accomplished by the modification of a well defined and/or localized rule and a symbol table. As a result, one can update the syntax to be generated by updating the artifacts of the \textit{Templates} module or just exchanging this module by another one (respecting the interface contracts), without having to change any other modules.


Apesar de o exemplo apresentado estar relacionado ao PLang, que representa conceitos de linguagens de programação, nosa abordagem não está restrita a gerar texto apenas para linguagens de programação. O MetaTT depende de um metamodelo, mas não depende da semântica específica de um metamodelo. Também é importante destacar que apesar de usarmos uma gramática BNF como descrição da sintaxe no nosso exemplo, nós não obrigamos a adoção de qualquer regra de formação em nosso templates, de maneira que o desenvolvedor fica livre pra mudar a sintaxe de acordo com o que o desenvolvedor achar conveniente. Por exemplo, se o desenvolvedor precisa de um gerador M2T para a linguagem de marcação HTML, ele ou ela precisa (1) prover um metamodelo de HTML para o MetaTT, (2) ajustar o módulo Main para transformar o elemento raíz do metamodelo de HTML (que deve ser o metaelemento ``html'') e (3) preencher as regras de templates e definir os terminais. Com o objetivo de realizar a atividade (3) ele ou ela não depende de uma descrição em gramática, e a descrição da sintaxe pode seer feita pelo desenvolvedor com base em exemplos ou conhecimento prévio que ele ou ela já tem sobre a sintaxe de HTML.

%Although the given example is related to PLang, that represents programming language concepts, our approach is not restricted to generate text only to programming languages. MetaTT depends on a metamodel, but not on the semantic of such metamodel. It is also important to highlight that although we use a BNF grammar as a description of the syntax in our example, we do not enforce any formation rule in our templates so that the developer is free to change it as he or she desires. For instance, if the developer needs a M2T generator for HTML, he or she  needs (1) to provide a HTML metamodel to MetaTT, (2) to adjust the Main module to transform the root element of the HTML metamodel (that may be the element named ``html'') and (3) to fulfill the template rules and to define the terminals. In order to do activity (3) he or she does not depend on a grammar description, and the description of the syntax can be defined by the developer based on examples or on the previous knowledge that he or she already has about HTML syntax.


\subsection{Core}

%This module provides rules for carrying out the textual transformation of each metaclass of the metamodel. It is further divided into two sub-modules: \textit{Extractor} and \textit{Collections}. 

Este módulo provê regras que são responsáveis por cuidar da transformação texutal de cada metaclasse do metamodelo. Ele é dividido em outros dois submódulos: \textit{Extractor} e \textit{Collections}.


%\textit{Extractor} sub-module is responsible for the extraction of the concrete syntax information of each metaclass of the metamodel, whereas \textit{Collections} sub-module manages the extraction of the concrete syntax information for collections of instances of a given metaclass. Both sub-modules depend on each other since they are responsible for complementary functionalities. Whenever textual information for a collection of elements is required inside the \textit{Extractor} sub-module, it accesses the functionality provided by the \textit{Collections} sub-module through the \textit{ICollectionExtractor} interface and whenever the transformation of a single element is required inside the \textit{Collections} sub-module it accesses the functionality of the \textit{Extractor} sub-module through the \textit{ITextExtractor} interface.

O sub-módulo \textit{Extractor} é responsável pela extração das informações de sintaxe concreta de cada metaclasse do metamodelo, enquanto que o sub-módulo \textit{Collections} gerencia a extração das informações de sintaxe concreta para coleções de instâncias de uma dada metaclasse. Estes dois submódulos dependem um do outro uma vez que são responsáveis por funcionalidades complementares. Sempre que informações de sintaxe concreta para uma coleção de elementos são necessárias dentro do sub-módulo \textit{Extractor}, ele acessa a funcionalidade provida pelo sub-módulo \textit{Collections} através da interface \textit{ICollectionExtractor} e sempre que a transformação de um único elemento precisa ser feita dentro do sub-módulo \textit{Collections}, ele acessa a funcionalidade do sub-módulo \textit{Extractor} através da interface \textit{ITextExtractor}.



%The rules in \textit{Extractor} sub-module are named \textit{extractor rules}. For each metaclass of the metamodel there is an extractor rule responsible for invoking rules capable of extracting the concrete syntax pieces (one for each attribute or reference of that metaclass) that together will form the whole syntax to that metaclass. The task of combining these syntax pieces is the role of the template rules (through the \textit{ITextualDefinitions} interface) from the \textit{Templates} module. For instance, for the \textit{ConditionalSttmnt} metaclass, illustrated in Fig.~\ref{conditional_statement}, there is an extractor rule, presented in Fig.~\ref{extractor_rule}. One can perceive the close relationship between the composition relationships of the \textit{ConditionalSttmnt} and the structure of the code presented in Fig.~\ref{extractor_rule}. For each relationship from the \textit{ConditionalSttmnt} metaclass targeting a \textit{Statement} or an \textit{Expression}, there is a rule invocation in the extractor rule, \textit{i.e.}, there is a correspondence between the member ends \textit{condition}, \textit{thenSttmnts} and \textit{elseSttmnts} from Fig.~\ref{conditional_statement} and lines 2, 3 and 4, respectively, from Fig.~\ref{extractor_rule}. At line 5, a template rule, named \textit{conditionalStatementTemplate}, is invoked to combine the syntax pieces captured at lines 2-4 forming the whole concrete syntax of the \textit{ConditionalSttmnt}.

As regras no sub-módulo \textit{Extractor} são nomeadas \textit{regras extratoras}. Para cada metaclasse do metamodelo há uma regra extratora responsável por invocar outras regras capazes de extrair as partes de sintaxe concreta (uma para cada atributo ou referência daquela metaclasse) que juntas formarão a sintaxe completa para aquela metaclasse. A tarefa de combinar esses pedaçõs de sintaxe é atribuída às regras de template (através da interface \textit{ITextualDefinitions}) do módulo \textit{Templates}. Por exemplo, para a metaclasse \textit{ConditionalSttmnt}, ilustrada na Fig.~\ref{conditional_statement}, há uma regra extratora, apresentada na Fig.~\ref{extractor_rule}. Pode-se perceber uma relação bastante próxima entre os relacionamentos de composição da metaclasse \textit{ConditionalSttmnt} e a estrutura do código apresentado na Fig.~\ref{extractor_rule}. Para cada relacionamento saindo da metaclasse \textit{ConditionalSttmnt} com destino para uma metaclasse \textit{Statement} ou \textit{Expression}, há a invocação de uma regra extratora, \textit{i.e.}, há uma correspondência entre os \textit{member ends} \textit{condition}, \textit{thenSttmnts} e \textit{elseSttmnts} na Fig.~\ref{conditional_statement} e linhas 2, 3 e 4, respectivamente, na Fig.~\ref{extractor_rule}. Na linha 5, uma regra de template, chamada \textit{conditionalSttmntTemplate}, é invocada para combinar os pedaços de sintaxe capturados nas linhas 2-4 formando a sintaxe completa do elemento \textit{ConditionalSttmnt}.




%At lines 3 and 4, in Fig.~\ref{extractor_rule}, some collection rules are invoked. Such rules are provided by the \textit{Collections} sub-module. They are responsible for abstracting the processing of collections of elements and enclosing them with their corresponding textual delimiters, obtained from the \textit{Templates} module through the required interface \textit{ITextualDelimiters}. In this example, the collections are required since a collection of \textit{then} and \textit{else} statements may be involved in a conditional statement. By separating these kinds of rules into a different module, MetaTT helps simplify the extractor rules.

Nas linhas 3 e 4, na Fig.~\ref{extractor_rule}, algumas regras de coleção são invocadas. Tais regras são providas pelo submódulo \textit{Collections}. Elas são responsáveis por abstrair o processamento de coleções de elementos e adicionar a estes seus correspondentes delimitadores textuais, obtidos do módulo \textit{Templates} através da interface \textit{ITextualDelimiters}. Neste exemplo, as coleções são requeridas uma vez que uma coleção de comandos \textit{then} e \textit{else} podem estar envolvidas na declaração de um comando condicional. Por separar estes três tipos de regras em três diferentes módulos, MetaTT ajuda a simplificar as regras extratoras.


\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.5]{conditional_statement}
\end{center}
\caption{A ConditionalSttmnt and its related metaelements.}
\label{conditional_statement}
\end{figure}


\begin{figure}[htb]
\begin{mofscript}
	\begin{lstlisting}[frame=single]
PLang.ConditionalSttmnt::getConditionalSttmntCode() : String {
 var condition:String= self.condition.getExpressionCode()
 var thenSttmnts:String= getStatementCollectionCode(self.thenSttmnts)
 var elseSttmnts:String= getStatementCollectionCode(self.elseSttmnts)
 result= conditionalSttmntTemplate(condition, thenSttmnts, elseSttmnts)
}
	\end{lstlisting}
\end{mofscript}
\caption{An extractor rule for a conditional statement in PLang.}
\label{extractor_rule}
\end{figure}


\subsection{Main.}

%This module comprises the start and the finish point of the model-to-text transformation. It contains an \textit{entry point rule} that receives an input model, identifies the metaclass this model is rooted and invokes the corresponding rule from Core module that in turn returns the concrete syntax for the given element. Finally, the \textit{entry point rule} performs the persistence of this syntax, finishing the process of model-to-text transformation.


Este módulo é responsável tanto pelo ponto inicial como pelo ponto final da transformação de modelo para texto. Ele contém uma regra de entrada que recebe um modelo de entrada, identifica a metaclasse raiz deste metamodelo e invoca a regra correspondente do módulo \textit{Core} que, por sua vez, retorna a sintaxe concreta para o dado elemento. Finalmente, a regra de entrada realiza a persistência da sintaxe concreta gerada, finalizando o processo de transformação.


%Whenever one wants to generate text for a given metaelement he or she needs to write a main rule that invokes the corresponding rule (an extractor rule already specified in the \textit{Core} module) for that metaelement. Fig.~\ref{main_rule_for_program} and Fig.~\ref{main_rule_for_function_declaration} are two slightly different examples of main rules. In both, the declaration of the context type of the rule (at line 1) allows an element to be automatically selected from the input model. At line 1, in Fig.~\ref{main_rule_for_program}, the transformation matches with \textit{ProgramDeclaration} elements and invokes the \textit{extractor rule} named \textit{getProgramDeclarationCode()} (at line 2) from the \textit{Core} module. Persistence is made at lines 3-4. Fig.~\ref{main_rule_for_function_declaration} is analogous to Fig.~\ref{main_rule_for_program}, but it performs the transformation for \textit{FunctionDeclaration} elements, \textit{i.e.}, it is responsible for generating the concrete syntax for the function declarations in PLang.


Sempre que se quer gerar texto para um dado metaelemento, escreve-se uma regra principal que invoque a regra adequada àquele elemento ( uma regra extratora já especificada no módulo \textit{Core}). As figuras~\ref{main_rule_for_program} e \ref{main_rule_for_function_declaration} são dois exemplos ligeiramente diferentes de regras principais. Em ambas, a declaração do tipo de contexto da regra (na linha 1) permitem que um elemento seja automaticamente selecionado no modelo de entrada. Na linha 1 da Fig.~\ref{main_rule_for_program}, a transformação detecta o elemento de contexto \textit{ProgramDeclaration}, seleciona os elementos de mesmo tipo no modelo de entrada e invoca a regra de estração chamada \textit{getProgramDeclarationCode()} (na linha 2) do módulo \textit{Core}. A persistência é feita nas linhas 3-4. A Fig.~\ref{main_rule_for_function_declaration} é análoga à Fig.~\ref{main_rule_for_program}, exceto pelo fato de que ele realiza a transformação de elementos do tipo \textit{FunctionDeclaration}, \textit{i.e.}, ela é responsável por gerar a sintaxe concreta para declarações de funções em PLang.


\begin{figure}[htb]
\begin{mofscript}
	\begin{lstlisting}[frame=single]
plang.ProgramDeclaration::main(){
 var code:String= self.getProgramDeclarationCode()
 file(self.name + ".plang")
 print(code)
}
	\end{lstlisting}
\end{mofscript}
\caption{A main rule that generates the code of every \textit{ProgramDeclaration} element.}
\label{main_rule_for_program}
\end{figure}


\begin{figure}[htb]
\begin{mofscript}
	\begin{lstlisting}[frame=single]
plang.FunctionDeclaration::main(){
 var code:String= self.getFunctionDeclarationCode()
 file(self.name + ".plang")
 print(code)
}
\end{lstlisting}
\end{mofscript}
\caption{A main rule that generates the code of every \textit{FunctionDeclaration} element.}
\label{main_rule_for_function_declaration}
\end{figure}



%A better control of the generation process is possible because the persistence is isolated in one module, \textit{i.e.} \textit{Main}, whereas the extraction of the text is isolated in another one, \textit{i.e.} \textit{Core}. The Main module is the only place in the whole text generator where there are print statements. This gives the transformer a better control over what should be printed to files.


Um melhor controle do processo de geraçãoé possível poque a persistência é isolada em um módulo, \textit{i.e.} \textit{Main}, enquanto o processo de extração de texto fica isolado em outro módulo, \textit{i.e} \textit{Core}. O módulo \textit{Main} é o único, dentre todos os módulos prescritos, que tem a presença de comandos \textit{print}. Isto confere ao desenvolvedor de transformações um melhor controle sobre o conteúdo que deve ser persistido em arquivos.

\subsection{Putting It All Together.}

%In this section we give an overview of the execution flow between the architectural modules. 

Nesta seção, nós apresentamos uma visão geral do fluxo de execução entre os módulos arquiteturais.

%In Fig.~\ref{activity_diagram_overview}, we present the main activities performed through the modules which are represented by swimlanes. Initially, in the \textit{Main} module, model elements are matched with the input model to be transformed. Then, the flow progresses to the activity of data extraction executed in the \textit{Core} module (by the \textit{Extractor} and \textit{Collections} sub-modules) whose details are omitted here for the sake of simplicity. After the needed data is extracted, they are combined by the \textit{Templates} module. The generated text is then persisted by the \textit{Main} module and the process finishes. 

Na Fig.~\ref{activity_diagram_overview}, nós apresentamos as principais atividades realizadas através dos módulos, que são representados por \textit{swimlanes}. Inicialmente, no módulo \textit{Main}, os elementos a serem transformados são selecionados. Então, o fluxo progride para a atividade de extração de dados, executada no módulo \textit{Core} (pelos sub-módulos \textit{Extractor} e \textit{Collections}) do qual omite-se os detalhes aqui por questões de simplificação. Depois que os dados necessários são extraídos, eles são combinados pelo módulo \textit{Templates}. O texto gerado é então persistido pelo módulo \textit{Main} que finaliza o processo.



\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.49]{activity_diagram_overview}
\caption{Overview of the activities performed in MetaTT.}
\label{activity_diagram_overview}
\end{center}
\end{figure}

%In Fig.~\ref{sequence_diagram}, we illustrate interactions occurring between the modules during the process of text generation to a conditional statement. In this context, the extractor rule \textit{getConditionalStatementCode()} is invoked from the module \textit{Main}. From this point, we emphasize the message exchanges among the transformations in different modules (that can be observed by the lifelines) for the rule presented in Fig.~\ref{extractor_rule}. The message callings progresses to the \textit{getConditionalStatementCode()} and the \textit{getExpressionCode()} extractor rules. Then, there are two callings (illustrated in the UML  \textit{ref} combined fragments) for the \textit{getStatementCollectionCode()} rule (one for the set of statements to be executed if the condition evaluates to true and another one otherwise), both from \textit{Collections} sub-module. Finally, the partial codes are combined into the \textit{Templates} module and the result is returned back to the \textit{Main} module to be persisted. 


Na Fig.~\ref{sequence_diagram}, ilustra-se as interações ocorridas entre os módulos durante o processo de geração de texto para um comando condicional. Neste contexto, a regra extratora \textit{getConditionalStatementCode()} é invocada a partir do módulo \textit{Main}. A partir desse ponto, enfatiza-se a troca de mensagems entre as transformações em diferentes módulos (que podem ser obervadas pelas \textit{lifelines}) para a regra apresentada na Fig.~\ref{extractor_rule}. As chamadas de mensagems progridem para as regras extratoras \textit{getConditionalStatementCode()} e \textit{getExpressionCode()}. Então, há duas chamadas (ilustradas num fragmento combinado \textit{ref} de UML) para a regra \textit{getStatementCollectionCode()} (uma para o conjunto de comandos a serem executados se a condição for avaliada como verdadeira e um outro conjunto para o caso oposto), ambas do sub-módulo \textit{Collections}. Finalmente, os códigos parciais são combinados no módulo \textit{Templates} e o resultado é retornado de volta ao módulo \textit{Main} para ser persistido.

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.4]{ConditionalStatement_vertical}
\caption{Sequence diagram illustrating the interactions among modules inside a PLang M2T generator.}
\label{sequence_diagram}
\end{center}
\end{figure}


\section{Generation of the Architectural Artifacts}

%After showing the prescribed modules and how they interact each other, we need to elaborate their internal artifacts, \textit{i.e.}, the transformations and their relationships and rule signatures. Important questions that arise in this process are: How many and what transformations should be created for each module? What rules should each transformation comprise? How will the rules be arranged into the transformations? What relationships should exist between the transformations?

Depois de preescrever os módulos arquiteturais e a maneira como eles interagem entre si, é preciso elaborar seus artefatos internos, \textit{i.e.}, as transformações e seus relacionamentos e assinaturas de regras. Questões importantes que surgem neste processão são: Quantas e quais transformações devem ser criatdas para cada módulo? Quais são as regras que cada transformação de conter? Como as regras serão arranjadas nas transformações de maneira coesa? Que relacionamentos devem existir entre as transformações?

%In order to answer the design questions and to ease the process of elaboration of the artifacts we adopt a \textit{reference model}, that contains the essential information for designing the M2T transformation artifacts. Such information is obtained from the metamodel to which the concrete syntax must be generated.

A fim de responder essas perguntas de projeto e a fim de facilitar o processo de elaboração de tais artefatos, um \textit{modelo de referência} deve ser adotado. Este modelo contém as informações essenciais para projetar os artefatos de transformações M2T. Tais informações são obtidas do metamodelo para o qual a sintaxe concreta deve ser gerada.

%The elements of the \textit{reference model} are used later to guide the derivation of artifacts, such as model-to-text transformations and  transformation rules.

Os elementos do \textit{modelo de referência} são usados, mais tarde, para guiar a obtenção dos artefatos, tais como transformações de modelo para texto e suas regras de transformação.

%The next subsections describe our approach to obtain the \textit{reference model} and how we elaborate the artifacts based on the information provided by such model.

As próximas subseções descrevem o método para obtenção do \textit{modelo de referência} e como os artefatos são elaborados com base nas informações providas por este modelo.

\subsection{From the Metamodel to the Reference Model.}
\label{obtaining_the_reference_model}


%From the metamodel, one must follow a stepwise process in order to obtain the reference model. This process synthesizes our approach for obtaining a reference for the implementation of the artifacts and the way they are comprised in the modules prescribed by the MetaTT architecture. The steps are:

A partir do metamodelo, deve-se seguir um processo com múltiplos passos a fim de se obter o modelo de referência. Este processo sintetisa a abordagem descrita neste trabalho para a obtenção de um referência para implementação dos artefatos de da maneira como eles se encaixa nos módulso propostos pela arquitetura do MetaTT. As passos são:

\begin{description}

\item[passo 1]
%To select the information (from the metamodel) needed to elaborate the reference model. Below, the metamodel elements (on the left) originate the \textit{reference elements}~\footnote{From this point, every element will be a \textit{reference element}.} (on the right):
Selecionar as informações (do metamodelo) necessárias para elaborar um modelo de referência. Abaixo, os elementos do metamodelo (na esquerda) originam os \textit{elementos de refer?ncia}~\footnote{A partir deste ponto, todo elemento será um \textit{elemento de referência}.} (na direita).


\begin{itemize}
 \item metaclasses $\rightarrow$ \textit{reference transformations} (identified by the same name of the corresponding metaclasses);
 \item inheritance relationships $\rightarrow$ directed \textit{reference associations} (following the direction child-to-parent in the metamodel).
\end{itemize}

From this point, the remaining information in the metamodel (compositions, attributes, etc.) are not used anymore, only the reference elements created (\textit{i.e.}, \textit{reference associations} and \textit{reference transformations}).
  
\item[step 2]
To verify if some \textit{reference transformation} in the resulting structure (from step 1) has two or more \textit{reference associations} targeting any other \textit{reference transformation} (it reveals whether there is multiple inheritance in the metamodel). If no, skip to step 3. If yes, then apply the normalization process: while there is two or more associations from a given \textit{reference transformation}, take it and merge all the \textit{reference transformations} it targets. Merging means that the targeted reference transformations will become only one and every reference association between the source reference transformation and the targeted ones becomes an unique reference association. This step guarantees that the structure of the reference model will have the form of a directed tree or a directed forest graph.

\item[step 3]
For every reference association which has a leaf \textit{reference transformation} in one of the ends, this leaf \textit{reference transformation} is turned into a \textit{reference rule} contained in its parent reference transformation. 

\item[step 4]
To reverse the directions of the reference associations. The targets become sources and vice-versa. Then, tag every reference association as an \textit{import} relationship.

\end{description}


The rationale for \textit{step 1} is to simplify the reference model selecting only essential information from the metamodel: Metaclasses and inheritance relationships. In \textit{step 2}, as we detect an element \textit{e} with multiple inheritance, we decided to merge its parents because they will further give origin to \textit{reference transformations} and then \textit{e} will give origin to a \textit{reference rule}; this rule could be added to only one of the transformations because we observed that duplicating the rule into more than one transformation could cause problems (in compilation and execution), then we observed that merging the parents and keeping only one \textit{reference rule} relative to \textit{e} inside the merged transformation is a better choice. In \textit{step 3}, grouping the \textit{reference rules} that are derived from metaelements which have a parent element in common is the way to keep good cohesion. In \textit{step 4}, some import relationships are derived from the resulting associations because they reflect the fact that the more abstract elements need the definitions of the less abstract ones. For instance, the actual rules that will be further derived from the \textit{reference rules} in the \textit{Expression reference transformation} will need the definitions of the rules derived from the \textit{reference rules} into \textit{Operation}, \textit{Reference} and \textit{Literal}.

In Fig.~\ref{passo_1}, the result of the application of the step 1 over the PLang metamodel is illustrated. After that, metaclasses become reference transformations and inheritance relationships become directed reference associations. It is worth taking a look at Fig.~\ref{plangmetamodel} to note the difference from the metamodel and the result of applying the step 1.


\begin{figure}[htb]
\begin{center}
\includegraphics[scale=.5]{reference_model_1}
\end{center}
\caption{A preliminary version of the reference model after the application of the \textit{step 1} on the PLang metamodel.}
\label{passo_1}
\end{figure}


\begin{figure}[ht!]
\begin{center}
\includegraphics[scale=.47]{reference_model_2}
\end{center}
\caption{A preliminary version of the reference model after the application of the \textit{step 2}.}
\label{passo_2}
\end{figure}


\begin{figure}[ht!]
\begin{center}
\includegraphics[scale=.4]{reference_model_7_inverted_arrows}
\end{center}
\caption{A preliminary version of the reference model after the application of the \textit{step 3}.}
\label{passo_4}
\end{figure}

During the application of the step 2, the presence of two reference associations from the same reference transformation to another ones is detected, \textit{i.e.}, both reference associations from \textit{FunctionDeclaration} and \textit{VariableDeclaration}  point to \textit{Declaration} and \textit{TypedDeclaration}. According to our approach, the targeted transformation references are merged into a single one, resulting into \textit{Declaration\_TypedDeclaration\_Merged}, illustrated in Fig.~\ref{passo_2}.


Fig.~\ref{passo_4} illustrates the result of applying the step 3. For instance, the leafs \textit{FunctionCall} and \textit{ConditionalExp} transformation references become rule references in the \textit{Expression} reference transformation. Conversely, \textit{Operation} is not turned into one rule reference since it is not a leaf element (\textit{e.g.}, \textit{BooleanOperation} is its child element).

As prescribed by the step 4, the direction of the reference associations are inverted and tagged as \textit{import} associations, shown in Fig.~\ref{ref_model}. 


Fig.~\ref{ref_model} shows the reference model for the implementation of the M2T generator for PLang. The rectangles tagged as \textit{texttransformation} are the reference transformations (\textit{e.g.}, \textit{ASTNode} and \textit{Expression}). The arrows tagged as \textit{import} between the reference transformations are reference associations (\textit{e.g.}, from \textit{ASTNode} to \textit{Expression} and from \textit{Expression} to \textit{Literal}). Additionally, inside each reference transformation we have the reference rules (\textit{e.g}, \textit{ConditionalExp()} and \textit{FunctionCall()}, both in the \textit{Expression} reference transformation).


Each one of the reference elements presented in Fig.~\ref{ref_model} is used to guide the elaboration of the model-to-text transformations and their respective transformation rules. In our approach, the transformation developer uses the reference model to know which transformations he or she will find in each module and the rules he or she will find in each transformation, as well as the relationships between them.



\begin{figure}[ht!]
\begin{center}
\includegraphics[scale=.4]{reference_model_7_imports}
\end{center}
\caption{The reference model obtained after the application of the \textit{step 4}.}
\label{ref_model}
\end{figure}


\subsection{Deriving Artifacts from the Reference Model.}

Once we know how to separate the different concerns inside the M2T generator by means of the proposed architecture, we use the reference model to design the model-to-text transformations, with their respective rules, inside each module. In general, this procedure is given as follows. For each reference transformation in the reference model, derive the following artifacts: 


\begin{itemize}

\item 
A transformation into the \textit{Extractor} sub-module, that, in turn, comprises one extractor rule for each reference rule. The extractor rules are exposed by the \textit{ITextExtractor} interface. They depend on the specification of the \textit{ITextualDefinitions} and the \textit{ICollectionExtractor} interfaces.

\item
A transformation into the \textit{Collections} sub-module, that, in turn, comprises one collection rule for each reference rule. The collection rules are exposed by the \textit{ICollectionExtractor} interface and they depend on the \textit{ITextualDelimiters} interface to work properly.

\item
A transformation into the \textit{Templates} sub-module, that, in turn, comprises one template rule stub for each reference rule. The transformations in this sub-module do not depend on any other module and they are exposed by the \textit{ITextualDefinitions} interface.

\item
Three properties in the \textit{TerminalSymbols} sub-module for each reference rule (such as two embraces and one separator, as prescribed in Fig.~\ref{mofscript_delimiters}). Such delimiters are exposed by the \textit{ITextualDelimiters} interface.

\end{itemize}

The role each transformation plays in the process of M2T transformations generation is according to the role played by its container modules (and sub-modules). Therefore, the transformation \textit{StatementExtractor}, from the \textit{Extractor} sub-module, performs data extraction, whereas the transformation \textit{StatementTemplates}, from the \textit{Templates} sub-module, specifies the concrete syntax for \textit{Statement} model elements. Analogous cases hold for the remaining transformations.



% END OF SECTION : METACG
